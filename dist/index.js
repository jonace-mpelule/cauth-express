import e from"bcrypt";import t,{z as n}from"zod";import{parsePhoneNumberFromString as r}from"libphonenumber-js";import i from"jsonwebtoken";async function a(e){return`${e?.error?.issues[0].path}: ${e?.error?.issues[0].message}`}const o=n.string().trim().refine(e=>{let t=r(e);return!!t&&t.isValid()},{message:`Invalid phone number`}).transform(e=>r(e)?.format(`E.164`)??e),s=n.object({email:n.string().email(),phoneNumber:n.never().optional(),password:n.string()}),c=n.object({phoneNumber:o,email:n.never().optional(),password:n.string()}),l=n.union([s,c]).superRefine((e,t)=>{e.email&&e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),u=n.object({phoneNumber:o.optional(),email:n.email().optional(),role:n.string(),password:n.string()}).superRefine((e,t)=>{!e.email&&!e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),d=n.object({refreshToken:n.jwt({message:`refreshToken: should be a valid jwt string`})}),f=n.object({refreshToken:n.jwt()}),p=n.object({accountId:n.string(),oldPassword:n.string(),newPassword:n.string()});async function m({config:t},{...n}){let r=p.safeParse(n);if(!r.success)return{success:!1,code:`invalid-body`,message:a(r)};let i=await t.dbProvider.findAccountById({id:n.accountId});if(!i)return{success:!1,code:`account-not-found`};if(!await e.compare(n.oldPassword,i.passwordHash))return{success:!1,code:`invalid-credentials`};let o=await e.hash(n.newPassword,10);return await t.dbProvider.updateAccount({id:i.id,data:{passwordHash:o}}),{success:!0,code:`password-changed`}}async function h({config:t,tokens:n},{...r}){let i=l.safeParse(r);if(!i.success)return{success:!1,code:`invalid-data-passed`,message:a(i)};let o=await t.dbProvider.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber});if(!o||!await e.compare(r.password,o.passwordHash))return{success:!1,code:`credential-mismatch`};let s=await n.GenerateTokenPairs({id:o.id,role:o.role});return await t.dbProvider.updateAccountLogin({id:o.id,refreshToken:s.refreshToken}),{success:!0,account:o,tokens:s}}async function g(e){try{return{data:await e,error:null}}catch(e){return{data:null,error:e}}}async function _({config:e,tokens:t},{...n}){if(!f.safeParse(n).success)return{success:!1,code:`invalid-data-passed`};let r=await g(t.VerifyRefreshToken(n.refreshToken));return r.error||!r?{success:!1,code:`invalid-refresh-token`}:(await e.dbProvider.removeAndAddRefreshToken({id:String(r.data?.id),refreshToken:n.refreshToken}),{success:!0,code:`logged-out`})}async function v({config:e,tokens:t},{...n}){if(!d.safeParse(n).success)return{success:!1,code:`invalid-data-passed`};let r=await g(t.VerifyRefreshToken(n.refreshToken));if(r.error)return{success:!1,code:`invalid-refresh-token`};let i=await e.dbProvider.findAccountById({id:String(r.data?.id)});if(!i)return{success:!1,code:`account-not-found`};if(!i.refreshTokens.includes(n.refreshToken))return{success:!1,code:`invalid-refresh-token`};let a=await t.GenerateTokenPairs({id:i.id,role:i.role});return await e.dbProvider.updateAccountLogin({id:i.id,refreshToken:a.refreshToken}),{success:!0,account:i,tokens:a}}var y=class extends Error{code;constructor(){super(`AccountAlreadyExists`),this.message=`Account already exists`,this.code=`duplicate-account`}},b=class extends Error{code;constructor(e){super(`Role should can only be; ${e.map(e=>e)}`),this.name=`InvalidRoleError`,this.code=`invalid-role`}};function x(e){return{success:!0,value:e}}function S(e){return{success:!1,error:e}}async function C({config:t,tokens:n},{...r}){let i=u.safeParse(r);if(!i.success)throw{success:!1,code:`invalid-data-passed`,message:a(i)};if(!t.roles?.includes(r.role))return S(new b(t.roles));if(await t.dbProvider.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber}))return S(new y);let o=await e.hash(r.password,10),s=await t.dbProvider.createAccount({data:{email:r.email,phoneNumber:r.phoneNumber,passwordHash:o,role:r.role,lastLogin:new Date}}),c=await n.GenerateTokenPairs({id:s.id,role:s.role});return await t.dbProvider.updateAccountLogin({id:s.id,refreshToken:c.refreshToken}),x({account:s,tokens:c})}async function w({...e}){return i.sign(e.payload,e.config.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`})}async function T({...e}){return i.sign(e.payload,e.config.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}async function E({...e}){let t=i.sign(e.payload,e.config.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`}),n=i.sign(e.payload,e.config.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`});return{accessToken:t,refreshToken:n}}async function D({...e}){let t=i.verify(e.token,e.config.refreshTokenSecret);return t instanceof String?null:t}async function O({...e}){let t=i.verify(e.token,e.config.accessTokenSecret);return t instanceof String?null:t}function k({config:e,tokens:t,roles:n}){return async(r,i,a)=>{try{let o=r.cookies?.accessToken;if(!o){let e=r.headers.authorization;e?.startsWith(`Bearer `)&&(o=e.split(` `)[1])}if(!o)return i.status(401).send({code:`invalid-token`});let s=await g(t.VerifyAccessToken(o));return s.error||!s.data?i.status(401).send({code:`invalid-token`}):n&&!n.includes(s.data.role)||!e.roles.includes(s.data.role)?i.status(403).send({code:`forbidden-resource`,message:`You don't have sufficient permission for this action`}):(r.cauth={id:s.data.id,role:s.data.role},a())}catch{return i.status(500).send({code:`server-error`})}}}function A({config:t,tokens:n}){return async(r,i)=>{try{let o=p.safeParse(r.body);if(!o.success)return i.status(400).send({code:`invalid-body`,message:await a(o)});let s=r.headers.authorization?.split(`Bearer `)[1];if(!s)return i.status(401).send({code:`missing-access-token`});let c=await g(n.VerifyAccessToken(s));if(c.error||!c)return i.status(401).send({code:`invalid-access-token`});let l=await t.dbProvider.findAccountById({id:String(c.data?.id)});if(!l)return i.status(404).send({code:`account-not-found`});if(!await e.compare(o.data.oldPassword,l.passwordHash))return i.status(401).send({code:`invalid-credentials`});let u=await e.hash(o.data.newPassword,10);return await t.dbProvider.updateAccount({id:l.id,data:{passwordHash:u}}),i.status(200).send({code:`password-changed`})}catch(e){return console.error(`ChangePassword error:`,e),i.status(500).send({code:`server-error`})}}}const j=t.object({id:t.string(),phoneNumber:t.string(),email:t.string(),passwordHash:t.string(),role:t.string(),lastLogin:t.date(),refreshTokens:t.string().array(),createdAt:t.date(),updatedAt:t.date()}),M={id:!0,phoneNumber:!0,email:!0,passwordHash:!1,role:!0,lastLogin:!0,refreshTokens:!1,createdAt:!0,updatedAt:!0};function N({config:t,tokens:n}){return async(r,i)=>{try{let o=l.safeParse(r.body);if(!o.success)return i.status(400).send({code:`invalid-body`,message:await a(o)});let{email:s,phoneNumber:c,password:u}=o.data,d=await t.dbProvider.findAccountWithCredential({email:s,phoneNumber:c});if(!d||!await e.compare(u,d.passwordHash))return i.status(409).send({code:`credential-mismatch`});let f=await n.GenerateTokenPairs({id:d.id,role:d.role}),p=await t.dbProvider.updateAccountLogin({id:d.id,refreshToken:f.refreshToken,select:M});return i.status(200).send({account:p,tokens:f})}catch(e){return console.error(`Login error:`,e),i.status(500).send({code:`server-error`})}}}function P({config:e,tokens:t}){return async(n,r)=>{try{let i=f.safeParse(n.body);if(!i.success)return r.status(400).send({code:`invalid-body`,message:a(i)});let{refreshToken:o}=i.data,s=await t.VerifyRefreshToken(o);return s?(await e.dbProvider.removeAndAddRefreshToken({id:s.id,refreshToken:o}),r.status(200).send({code:`logged-out`})):r.status(401).send({code:`invalid-refresh-token`})}catch(e){return console.error(`Logout error:`,e),r.status(500).send({code:`server-error`})}}}function F({config:e,tokens:t}){return async(n,r)=>{try{let i=d.safeParse(n.body);if(!i.success)return r.status(400).send({code:`invalid-body`,message:a(i)});let{refreshToken:o}=i.data,s=await t.VerifyRefreshToken(o);if(!s)return r.status(401).send({code:`invalid-refresh-token`});let c=await e.dbProvider.findAccountById({id:s.id});if(!c)return r.status(404).send({code:`account-not-found`});if(!c.refreshTokens.includes(o))return r.status(401).send({code:`invalid-refresh-token`});let l=await t.GenerateTokenPairs({id:c.id,role:c.role});return await e.dbProvider.removeAndAddRefreshToken({id:c.id,refreshToken:o,newRefreshToken:l.refreshToken,select:M}),r.status(200).send({tokens:l})}catch(e){return console.error(`Refresh token error:`,e),r.status(500).send({code:`server-error`})}}}function I({config:t,tokens:n}){return async(r,i)=>{try{let o=u.safeParse(r.body);if(!o.success)return i.status(400).send({code:`invalid-body`,message:await a(o)});let{email:s,phoneNumber:c,role:l,password:d}=o.data;if(!t.roles?.includes(l))return i.status(409).send({code:`invalid-role`,message:`role should can only be; ${t.roles?.map(e=>e)}`});if(await t.dbProvider.findAccountWithCredential({email:s,phoneNumber:c}))return i.status(409).send({code:`account-exists`});let f=await e.hash(d,10),p=await t.dbProvider.createAccount({data:{email:s,phoneNumber:c,passwordHash:f,role:l,lastLogin:new Date}}),m=await n.GenerateTokenPairs({id:p.id,role:l}),h=await t.dbProvider.updateAccountLogin({id:p.id,refreshToken:m.refreshToken,select:M});return i.status(201).send({account:h,tokens:m})}catch(e){return console.error(`Register error:`,e),i.status(500).send({code:`server-error`})}}}const L=t.custom(()=>!0,{message:`Invalid DbProvider: must implement DbProvider interface`}),R=t.custom(),z=t.object({dbProvider:L,refreshTokenSecret:t.string(),accessTokenSecret:t.string(),roles:t.array(t.string()).min(1),jwtConfig:t.object({accessTokenLifeSpan:R.optional(),refreshTokenLifeSpan:R.optional()}).optional()});var B=class{#config;constructor(e){if(!z.safeParse(e).success)throw Error(`❌ Failed to initiate CAuth. You provided an invalid config!`);this.#config=e}get RoleType(){return null}get roles(){return this.#config.roles}isRole(e){return this.#config.roles.includes(e)}Guard=e=>k({config:this.#config,tokens:this.Tokens,roles:e});Routes={Login:()=>N({config:this.#config,tokens:this.Tokens}),Register:()=>I({config:this.#config,tokens:this.Tokens}),Logout:()=>P({config:this.#config,tokens:this.Tokens}),Refresh:()=>F({config:this.#config,tokens:this.Tokens}),ChangePassword:()=>A({config:this.#config,tokens:this.Tokens})};FN={Login:({...e})=>h({config:this.#config,tokens:this.Tokens},e),Register:({...e})=>C({config:this.#config,tokens:this.Tokens},e),Logout:({...e})=>_({config:this.#config,tokens:this.Tokens},e),Refresh:({...e})=>v({config:this.#config,tokens:this.Tokens},e),ChangePassword:({...e})=>m({config:this.#config,tokens:this.Tokens},e)};Tokens={GenerateRefreshToken:e=>T({payload:e,config:this.#config}),GenerateAccessToken:e=>w({payload:e,config:this.#config}),GenerateTokenPairs:e=>E({payload:e,config:this.#config}),VerifyRefreshToken:e=>D({token:e,config:this.#config}),VerifyAccessToken:e=>O({token:e,config:this.#config})}};function V(e){return new B(e)}var H=class{#client;constructor(e){this.client=e,this.#client=e}async findAccountById({id:e}){return await this.#client.auth.findFirst({where:{id:e}})}async findAccountByEmail({email:e}){return await this.#client.auth.findFirst({where:{email:e}})}async findAccountWithCredential({...e}){return await this.#client.auth.findFirst({where:{OR:[{email:e.email},{phoneNumber:e.phoneNumber}]},select:e.select})}async createAccount({...e}){return await this.#client.auth.create({data:e.data})}async removeAndAddRefreshToken({id:e,refreshToken:t,select:n,newRefreshToken:r}){let i=await this.findAccountById({id:e});if(!i)throw Error(`account-not-found: ${e}`);let a=i.refreshTokens.filter(e=>e!==t);return r&&(a.push(r),a=Array.from(new Set(a))),this.#client.auth.update({where:{id:e},data:{refreshTokens:{set:a}},select:n})}async updateAccountLogin({...e}){return this.#client.auth.update({where:{id:e.id},data:{lastLogin:new Date,refreshTokens:{push:e.refreshToken}},select:e.select})}async updateAccount({...e}){return await this.#client.auth.update({where:{id:e.id},data:e.data})}async deleteAccount({id:e}){return await this.#client.auth.delete({where:{id:e}})}};export{j as AuthModelSchema,M as AuthModelSelect,V as CAuth,z as CAuthOptionsSchema,H as PrismaProvider};