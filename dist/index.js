import e from"bcrypt";import t,{z as n}from"zod";import{parsePhoneNumberFromString as r}from"libphonenumber-js";import i from"jsonwebtoken";var a=class extends Error{code;constructor(){super(`AccountAlreadyExists`),this.message=`Account already exists`,this.code=`duplicate-account`}},o=class extends Error{code;constructor(e){super(`Role should can only be; ${e.map(e=>e)}`),this.name=`InvalidRoleError`,this.code=`invalid-role`}},s=class extends Error{code;constructor(e){super(e),this.name=`InvalidDataError`,this.code=`invalid-data`}},c=class extends Error{code;constructor(){super(`Credentials do not match any account`),this.name=`CredentialMismatchError`,this.code=`credential-mismatch`}},l=class extends Error{code;constructor(){super(`Invalid refresh token`),this.name=`InvalidTokenError`,this.code=`invalid-refresh-token`}},u=class extends Error{code;constructor(){super(`Account not found`),this.name=`AccountNotFoundError`,this.code=`account-not-found`}};async function d(e){return`${e?.error?.issues[0].path}: ${e?.error?.issues[0].message}`}const f=n.string().trim().refine(e=>{let t=r(e);return!!t&&t.isValid()},{message:`Invalid phone number`}).transform(e=>r(e)?.format(`E.164`)??e),p=n.object({email:n.string().email(),phoneNumber:n.never().optional(),password:n.string()}),m=n.object({phoneNumber:f,email:n.never().optional(),password:n.string()}),h=n.union([p,m]).superRefine((e,t)=>{e.email&&e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),g=n.object({phoneNumber:f.optional(),email:n.email().optional(),role:n.string(),password:n.string()}).superRefine((e,t)=>{!e.email&&!e.phoneNumber&&t.addIssue({code:n.ZodIssueCode.custom,message:`Provide either email or phoneNumber`,path:[`email`,`phoneNumber`]})}),_=n.object({refreshToken:n.jwt({message:`refreshToken: should be a valid jwt string`})}),v=n.object({refreshToken:n.jwt()}),y=n.object({accountId:n.string(),oldPassword:n.string(),newPassword:n.string()});function b(e){return{success:!0,value:e}}function x(e){return{success:!1,error:e}}async function S({config:t},{...n}){let r=y.safeParse(n);if(!r.success)return x(new s(await d(r)));let i=await t.dbProvider.findAccountById({id:n.accountId});if(!i)return x(new u);if(!await e.compare(n.oldPassword,i.passwordHash))return x(new c);let a=await e.hash(n.newPassword,10);return await t.dbProvider.updateAccount({id:i.id,data:{passwordHash:a}}),b({code:`password-changed`})}async function C({config:t,tokens:n},{...r}){if(!h.safeParse(r).success)return x(new s(`invalid-data-passed`));let i=await t.dbProvider.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber});if(!i||!await e.compare(r.password,i.passwordHash))return x(new c);let a=await n.GenerateTokenPairs({id:i.id,role:i.role});return await t.dbProvider.updateAccountLogin({id:i.id,refreshToken:a.refreshToken}),b({account:i,tokens:a})}async function w(e){try{return{data:await e,error:null}}catch(e){return{data:null,error:e}}}async function T({config:e,tokens:t},{...n}){if(!v.safeParse(n).success)return x(new s(`invalid-data-passed`));let r=await w(t.VerifyRefreshToken(n.refreshToken));return r.error||!r?x(new l):(await e.dbProvider.removeAndAddRefreshToken({id:String(r.data?.id),refreshToken:n.refreshToken}),b({code:`logged-out`}))}async function E({config:e,tokens:t},{...n}){if(!_.safeParse(n).success)return x(new s(`Invalid data passed`));let r=await w(t.VerifyRefreshToken(n.refreshToken));if(r.error)return x(new l);let i=await e.dbProvider.findAccountById({id:String(r.data?.id)});if(!i)return x(new u);if(!i.refreshTokens.includes(n.refreshToken))return x(new l);let a=await t.GenerateTokenPairs({id:i.id,role:i.role});return await e.dbProvider.updateAccountLogin({id:i.id,refreshToken:a.refreshToken}),b({account:i,tokens:a})}async function D({config:t,tokens:n},{...r}){let i=g.safeParse(r);if(!i.success)return x(new s(await d(i)));if(!t.roles?.includes(r.role))return x(new o(t.roles));if(await t.dbProvider.findAccountWithCredential({email:r.email,phoneNumber:r.phoneNumber}))return x(new a);let c=await e.hash(r.password,10),l=await t.dbProvider.createAccount({data:{email:r.email,phoneNumber:r.phoneNumber,passwordHash:c,role:r.role,lastLogin:new Date}}),u=await n.GenerateTokenPairs({id:l.id,role:l.role});return await t.dbProvider.updateAccountLogin({id:l.id,refreshToken:u.refreshToken}),b({account:l,tokens:u})}async function O({...e}){return i.sign(e.payload,e.config.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`})}async function k({...e}){return i.sign(e.payload,e.config.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`})}async function A({...e}){let t=i.sign(e.payload,e.config.accessTokenSecret,{expiresIn:e.config.jwtConfig?.accessTokenLifeSpan??`15m`}),n=i.sign(e.payload,e.config.refreshTokenSecret,{expiresIn:e.config.jwtConfig?.refreshTokenLifeSpan??`30d`});return{accessToken:t,refreshToken:n}}async function j({...e}){let t=i.verify(e.token,e.config.refreshTokenSecret);return t instanceof String?null:t}async function M({...e}){let t=i.verify(e.token,e.config.accessTokenSecret);return t instanceof String?null:t}function N({config:e,tokens:t,roles:n}){return async(r,i,a)=>{try{let o=r.cookies?.accessToken;if(!o){let e=r.headers.authorization;e?.startsWith(`Bearer `)&&(o=e.split(` `)[1])}if(!o)return i.status(401).send({code:`invalid-token`});let s=await w(t.VerifyAccessToken(o));return s.error||!s.data?i.status(401).send({code:`invalid-token`}):n&&!n.includes(s.data.role)||!e.roles.includes(s.data.role)?i.status(403).send({code:`forbidden-resource`,message:`You don't have sufficient permission for this action`}):(r.cauth={id:s.data.id,role:s.data.role},a())}catch{return i.status(500).send({code:`server-error`})}}}function P({config:t,tokens:n}){return async(r,i)=>{try{let a=y.safeParse(r.body);if(!a.success)return i.status(400).send({code:`invalid-body`,message:await d(a)});let o=r.headers.authorization?.split(`Bearer `)[1];if(!o)return i.status(401).send({code:`missing-access-token`});let s=await w(n.VerifyAccessToken(o));if(s.error||!s)return i.status(401).send({code:`invalid-access-token`});let c=await t.dbProvider.findAccountById({id:String(s.data?.id)});if(!c)return i.status(404).send({code:`account-not-found`});if(!await e.compare(a.data.oldPassword,c.passwordHash))return i.status(401).send({code:`invalid-credentials`});let l=await e.hash(a.data.newPassword,10);return await t.dbProvider.updateAccount({id:c.id,data:{passwordHash:l}}),i.status(200).send({code:`password-changed`})}catch(e){return console.error(`ChangePassword error:`,e),i.status(500).send({code:`server-error`})}}}const F=t.object({id:t.string(),phoneNumber:t.string(),email:t.string(),passwordHash:t.string(),role:t.string(),lastLogin:t.date(),refreshTokens:t.string().array(),createdAt:t.date(),updatedAt:t.date()}),I={id:!0,phoneNumber:!0,email:!0,passwordHash:!1,role:!0,lastLogin:!0,refreshTokens:!1,createdAt:!0,updatedAt:!0};function L({config:t,tokens:n}){return async(r,i)=>{try{let a=h.safeParse(r.body);if(!a.success)return i.status(400).send({code:`invalid-body`,message:await d(a)});let{email:o,phoneNumber:s,password:c}=a.data,l=await t.dbProvider.findAccountWithCredential({email:o,phoneNumber:s});if(!l||!await e.compare(c,l.passwordHash))return i.status(409).send({code:`credential-mismatch`});let u=await n.GenerateTokenPairs({id:l.id,role:l.role}),f=await t.dbProvider.updateAccountLogin({id:l.id,refreshToken:u.refreshToken,select:I});return i.status(200).send({account:f,tokens:u})}catch(e){return console.error(`Login error:`,e),i.status(500).send({code:`server-error`})}}}function R({config:e,tokens:t}){return async(n,r)=>{try{let i=v.safeParse(n.body);if(!i.success)return r.status(400).send({code:`invalid-body`,message:d(i)});let{refreshToken:a}=i.data,o=await t.VerifyRefreshToken(a);return o?(await e.dbProvider.removeAndAddRefreshToken({id:o.id,refreshToken:a}),r.status(200).send({code:`logged-out`})):r.status(401).send({code:`invalid-refresh-token`})}catch(e){return console.error(`Logout error:`,e),r.status(500).send({code:`server-error`})}}}function z({config:e,tokens:t}){return async(n,r)=>{try{let i=_.safeParse(n.body);if(!i.success)return r.status(400).send({code:`invalid-body`,message:d(i)});let{refreshToken:a}=i.data,o=await t.VerifyRefreshToken(a);if(!o)return r.status(401).send({code:`invalid-refresh-token`});let s=await e.dbProvider.findAccountById({id:o.id});if(!s)return r.status(404).send({code:`account-not-found`});if(!s.refreshTokens.includes(a))return r.status(401).send({code:`invalid-refresh-token`});let c=await t.GenerateTokenPairs({id:s.id,role:s.role});return await e.dbProvider.removeAndAddRefreshToken({id:s.id,refreshToken:a,newRefreshToken:c.refreshToken,select:I}),r.status(200).send({tokens:c})}catch(e){return console.error(`Refresh token error:`,e),r.status(500).send({code:`server-error`})}}}function B({config:t,tokens:n}){return async(r,i)=>{try{let a=g.safeParse(r.body);if(!a.success)return i.status(400).send({code:`invalid-body`,message:await d(a)});let{email:o,phoneNumber:s,role:c,password:l}=a.data;if(!t.roles?.includes(c))return i.status(409).send({code:`invalid-role`,message:`role should can only be; ${t.roles?.map(e=>e)}`});if(await t.dbProvider.findAccountWithCredential({email:o,phoneNumber:s}))return i.status(409).send({code:`account-exists`});let u=await e.hash(l,10),f=await t.dbProvider.createAccount({data:{email:o,phoneNumber:s,passwordHash:u,role:c,lastLogin:new Date}}),p=await n.GenerateTokenPairs({id:f.id,role:c}),m=await t.dbProvider.updateAccountLogin({id:f.id,refreshToken:p.refreshToken,select:I});return i.status(201).send({account:m,tokens:p})}catch(e){return console.error(`Register error:`,e),i.status(500).send({code:`server-error`})}}}const V=t.custom(()=>!0,{message:`Invalid DbProvider: must implement DbProvider interface`}),H=t.custom(),U=t.object({dbProvider:V,refreshTokenSecret:t.string(),accessTokenSecret:t.string(),roles:t.array(t.string()).min(1),jwtConfig:t.object({accessTokenLifeSpan:H.optional(),refreshTokenLifeSpan:H.optional()}).optional()});var W=class{#config;constructor(e){if(!U.safeParse(e).success)throw Error(`❌ Failed to initiate CAuth. You provided an invalid config!`);this.#config=e}get RoleType(){return null}Guard=e=>N({config:this.#config,tokens:this.Tokens,roles:e});Routes={Login:()=>L({config:this.#config,tokens:this.Tokens}),Register:()=>B({config:this.#config,tokens:this.Tokens}),Logout:()=>R({config:this.#config,tokens:this.Tokens}),Refresh:()=>z({config:this.#config,tokens:this.Tokens}),ChangePassword:()=>P({config:this.#config,tokens:this.Tokens})};FN={Login:({...e})=>C({config:this.#config,tokens:this.Tokens},e),Register:({...e})=>D({config:this.#config,tokens:this.Tokens},e),Logout:({...e})=>T({config:this.#config,tokens:this.Tokens},e),Refresh:({...e})=>E({config:this.#config,tokens:this.Tokens},e),ChangePassword:({...e})=>S({config:this.#config,tokens:this.Tokens},e)};Tokens={GenerateRefreshToken:e=>k({payload:e,config:this.#config}),GenerateAccessToken:e=>O({payload:e,config:this.#config}),GenerateTokenPairs:e=>A({payload:e,config:this.#config}),VerifyRefreshToken:e=>j({token:e,config:this.#config}),VerifyAccessToken:e=>M({token:e,config:this.#config})}};function G(e){return new W(e)}var K=class{#client;constructor(e){this.client=e,this.#client=e}async findAccountById({id:e}){return await this.#client.auth.findFirst({where:{id:e}})}async findAccountByEmail({email:e}){return await this.#client.auth.findFirst({where:{email:e}})}async findAccountWithCredential({...e}){return await this.#client.auth.findFirst({where:{OR:[{email:e.email},{phoneNumber:e.phoneNumber}]},select:e.select})}async createAccount({...e}){return await this.#client.auth.create({data:e.data})}async removeAndAddRefreshToken({id:e,refreshToken:t,select:n,newRefreshToken:r}){let i=await this.findAccountById({id:e});if(!i)throw Error(`account-not-found: ${e}`);let a=i.refreshTokens.filter(e=>e!==t);return r&&(a.push(r),a=Array.from(new Set(a))),this.#client.auth.update({where:{id:e},data:{refreshTokens:{set:a}},select:n})}async updateAccountLogin({...e}){return this.#client.auth.update({where:{id:e.id},data:{lastLogin:new Date,refreshTokens:{push:e.refreshToken}},select:e.select})}async updateAccount({...e}){return await this.#client.auth.update({where:{id:e.id},data:e.data})}async deleteAccount({id:e}){return await this.#client.auth.delete({where:{id:e}})}};export{u as AccountNotFoundError,F as AuthModelSchema,I as AuthModelSelect,G as CAuth,U as CAuthOptionsSchema,c as CredentialMismatchError,a as DuplicateAccountError,s as InvalidDataError,l as InvalidRefreshTokenError,o as InvalidRoleError,K as PrismaProvider};